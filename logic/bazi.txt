// AI命理大师 - 八字个性化分析 Edge Function - 完全基于用户数据无占位符版本
Deno.serve(async (req)=>{
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, PUT, DELETE, PATCH',
    'Access-Control-Max-Age': '86400',
    'Access-Control-Allow-Credentials': 'false'
  };
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      status: 200,
      headers: corsHeaders
    });
  }
  try {
    const requestBody = await req.text();
    console.log('Bazi analyzer request:', requestBody);
    let requestData;
    try {
      requestData = JSON.parse(requestBody);
    } catch (parseError) {
      console.error('JSON parse error:', parseError);
      return new Response(JSON.stringify({
        error: {
          code: 'INVALID_JSON',
          message: 'Invalid JSON in request body'
        }
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const { user_id, birth_data } = requestData;
    const reading_type = 'bazi';
    console.log('Bazi analysis request:', {
      user_id,
      reading_type,
      birth_data
    });
    if (!user_id || !birth_data) {
      throw new Error('Missing required parameters: user_id or birth_data');
    }
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing Supabase configuration');
    }
    // 执行完全个性化的八字分析
    const analysisResult = await performFullBaziAnalysis(birth_data);
    console.log('Complete Bazi analysis generated');
    // 保存分析结果到数据库 - 使用正确的 numerology_readings 表
    const recordData = {
      user_id,
      reading_type: 'bazi',
      name: birth_data.name || null,
      birth_date: birth_data.birth_date,
      birth_time: birth_data.birth_time || null,
      gender: birth_data.gender,
      birth_place: birth_data.birth_place || null,
      input_data: birth_data,
      results: {
        result_data: analysisResult,
        analysis_type: 'bazi'
      },
      analysis: analysisResult,
      status: 'completed'
    };
    const saveResponse = await fetch(`${supabaseUrl}/rest/v1/numerology_readings`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${supabaseKey}`,
        'apikey': supabaseKey,
        'Prefer': 'return=representation'
      },
      body: JSON.stringify(recordData)
    });
    if (!saveResponse.ok) {
      const errorText = await saveResponse.text();
      console.error('Save bazi analysis error:', errorText);
      throw new Error(`Failed to save analysis: ${errorText}`);
    }
    const savedRecord = await saveResponse.json();
    console.log('Saved personalized bazi analysis successfully');
    return new Response(JSON.stringify({
      data: {
        record_id: savedRecord[0]?.id,
        analysis: analysisResult
      }
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('Bazi analyzer error:', error);
    const errorResponse = {
      error: {
        code: 'BAZI_ANALYSIS_ERROR',
        message: error.message
      }
    };
    return new Response(JSON.stringify(errorResponse), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});
// 完全个性化的八字分析主函数 - 基于真实用户数据
async function performFullBaziAnalysis(birth_data) {
  try {
    const { birth_date, birth_time, gender, birth_place, name } = birth_data;
    const personalizedName = name || '您';
    // 1. 精确计算八字四柱
    const baziChart = calculatePreciseBazi(birth_date, birth_time);
    // 2. 详细五行分析
    const wuxingAnalysis = performDetailedWuxingAnalysis(baziChart, gender, personalizedName);
    // 3. 精确格局判定
    const patternAnalysis = determineAccuratePattern(baziChart, gender, personalizedName);
    // 4. 精准大运流年分析
    const fortuneAnalysis = calculatePreciseFortune(baziChart, birth_date, gender, personalizedName);
    // 5. 综合人生指导
    const lifeGuidance = generateComprehensiveLifeGuidance(baziChart, patternAnalysis, wuxingAnalysis, gender, personalizedName);
    // 6. 现代应用建议
    const modernGuidance = generateModernApplications(baziChart, patternAnalysis, gender, personalizedName);
    return {
      analysis_type: 'bazi',
      analysis_date: new Date().toISOString().split('T')[0],
      basic_info: {
        personal_data: {
          name: personalizedName,
          birth_date: birth_date,
          birth_time: birth_time || '12:00',
          gender: gender === 'male' || gender === '男' ? '男性' : '女性',
          birth_place: birth_place || '未提供'
        },
        bazi_chart: baziChart,
        lunar_info: calculateLunarInfo(birth_date)
      },
      wuxing_analysis: {
        element_distribution: wuxingAnalysis.distribution,
        balance_analysis: wuxingAnalysis.detailed_analysis,
        personal_traits: wuxingAnalysis.personality_traits,
        suggestions: wuxingAnalysis.improvement_suggestions
      },
      geju_analysis: {
        pattern_type: patternAnalysis.pattern_name,
        pattern_strength: patternAnalysis.strength,
        characteristics: patternAnalysis.detailed_traits,
        career_path: patternAnalysis.suitable_careers,
        life_meaning: patternAnalysis.philosophical_meaning,
        development_strategy: patternAnalysis.action_plan
      },
      dayun_analysis: {
        current_age: fortuneAnalysis.current_age,
        current_dayun: fortuneAnalysis.current_period,
        dayun_sequence: fortuneAnalysis.life_periods,
        yearly_fortune: fortuneAnalysis.current_year_analysis,
        future_outlook: fortuneAnalysis.next_decade_forecast
      },
      life_guidance: {
        overall_summary: lifeGuidance.comprehensive_summary,
        career_development: lifeGuidance.career_guidance,
        wealth_management: lifeGuidance.wealth_guidance,
        marriage_relationships: lifeGuidance.relationship_guidance,
        health_wellness: lifeGuidance.health_guidance,
        personal_development: lifeGuidance.self_improvement
      },
      modern_applications: {
        lifestyle_recommendations: modernGuidance.daily_life,
        career_strategies: modernGuidance.professional_development,
        relationship_advice: modernGuidance.interpersonal_skills,
        decision_making: modernGuidance.timing_guidance
      }
    };
  } catch (error) {
    console.error('Complete Bazi analysis error:', error);
    throw error;
  }
}
// 精确计算八字四柱
function calculatePreciseBazi(birth_date, birth_time) {
  const heavenlyStems = [
    '甲',
    '乙',
    '丙',
    '丁',
    '戊',
    '己',
    '庚',
    '辛',
    '壬',
    '癸'
  ];
  const earthlyBranches = [
    '子',
    '丑',
    '寅',
    '卯',
    '辰',
    '巳',
    '午',
    '未',
    '申',
    '酉',
    '戌',
    '亥'
  ];
  const birthDate = new Date(birth_date);
  const birthYear = birthDate.getFullYear();
  const birthMonth = birthDate.getMonth() + 1;
  const birthDay = birthDate.getDate();
  const birthHour = birth_time ? parseInt(birth_time.split(':')[0]) : 12;
  // 精确的干支计算
  const yearStemIndex = (birthYear - 4) % 10;
  const yearBranchIndex = (birthYear - 4) % 12;
  const monthStemIndex = (yearStemIndex * 2 + birthMonth) % 10;
  const monthBranchIndex = (birthMonth + 1) % 12;
  const daysSinceEpoch = Math.floor((birthDate - new Date('1900-01-01')) / (1000 * 60 * 60 * 24));
  const dayStemIndex = (daysSinceEpoch + 9) % 10;
  const dayBranchIndex = (daysSinceEpoch + 9) % 12;
  const hourStemIndex = (dayStemIndex * 2 + Math.floor((birthHour + 1) / 2)) % 10;
  const hourBranchIndex = Math.floor((birthHour + 1) / 2) % 12;
  const result = {
    year_pillar: {
      stem: heavenlyStems[yearStemIndex],
      branch: earthlyBranches[yearBranchIndex],
      element: getElementFromStem(heavenlyStems[yearStemIndex])
    },
    month_pillar: {
      stem: heavenlyStems[monthStemIndex],
      branch: earthlyBranches[monthBranchIndex],
      element: getElementFromStem(heavenlyStems[monthStemIndex])
    },
    day_pillar: {
      stem: heavenlyStems[dayStemIndex],
      branch: earthlyBranches[dayBranchIndex],
      element: getElementFromStem(heavenlyStems[dayStemIndex])
    },
    hour_pillar: {
      stem: heavenlyStems[hourStemIndex],
      branch: earthlyBranches[hourBranchIndex],
      element: getElementFromStem(heavenlyStems[hourStemIndex])
    },
    day_master: heavenlyStems[dayStemIndex],
    complete_chart: `${heavenlyStems[yearStemIndex]}${earthlyBranches[yearBranchIndex]} ${heavenlyStems[monthStemIndex]}${earthlyBranches[monthBranchIndex]} ${heavenlyStems[dayStemIndex]}${earthlyBranches[dayBranchIndex]} ${heavenlyStems[hourStemIndex]}${earthlyBranches[hourBranchIndex]}`
  };
  return result;
}
// 详细五行分析
function performDetailedWuxingAnalysis(baziChart, gender, name) {
  const dayMaster = baziChart.day_master;
  const dayMasterElement = getElementFromStem(dayMaster);
  // 统计五行分布
  const elements = {
    '木': 0,
    '火': 0,
    '土': 0,
    '金': 0,
    '水': 0
  };
  [
    'year_pillar',
    'month_pillar',
    'day_pillar',
    'hour_pillar'
  ].forEach((pillar)=>{
    const stemElement = baziChart[pillar].element;
    const branchElement = getBranchElement(baziChart[pillar].branch);
    elements[stemElement]++;
    elements[branchElement]++;
  });
  const sortedElements = Object.entries(elements).sort((a, b)=>b[1] - a[1]);
  const strongestElement = sortedElements[0][0];
  const weakestElement = sortedElements[sortedElements.length - 1][0];
  // 生成完全个性化的分析
  const genderTitle = gender === 'male' || gender === '男' ? '男命' : '女命';
  const personalityTraits = generatePersonalityFromDayMaster(dayMaster, gender, elements);
  const balanceAnalysis = generateBalanceAnalysis(elements, dayMasterElement, strongestElement, weakestElement, name);
  const improvementSuggestions = generateImprovementSuggestions(dayMasterElement, weakestElement, strongestElement, name, gender);
  return {
    distribution: elements,
    detailed_analysis: `${name}的八字中，日主${dayMaster}(${dayMasterElement}元素)，${genderTitle}${dayMasterElement}命格具有${getElementNatureDescription(dayMasterElement)}的特质。${balanceAnalysis}`,
    personality_traits: personalityTraits,
    improvement_suggestions: improvementSuggestions
  };
}
// 生成个性特质描述
function generatePersonalityFromDayMaster(dayMaster, gender, elements) {
  const dayMasterTraits = {
    '甲': '如参天大树般正直挺拔，具有开拓进取的精神和天然的领导气质',
    '乙': '如花草般柔韧而富有生命力，具有很强的适应能力和艺术天赋',
    '丙': '如太阳般光明磊落，性格开朗热情，具有很强的感染力和表现欲',
    '丁': '如星火般温暖细腻，思维敏锐，具有细致的观察力和创意能力',
    '戊': '如高山般稳重厚实，具有很强的责任心和包容心，值得信赖',
    '己': '如沃土般温和包容，具有很好的亲和力和协调能力，善于照顾他人',
    '庚': '如利剑般刚毅果断，具有很强的原则性和执行力，做事雷厉风行',
    '辛': '如珠宝般精致优雅，注重品质和细节，具有很好的审美能力',
    '壬': '如江河般胸怀宽广，具有很强的包容性和变通能力，智慧深邃',
    '癸': '如露水般纯净灵性，直觉敏锐，具有很强的感知能力和同情心'
  };
  const baseTraits = dayMasterTraits[dayMaster] || '性格温和平衡，具有良好的适应能力';
  const genderModification = gender === 'male' || gender === '男' ? '，在男性特质上表现为坚毅和担当' : '，在女性特质上表现为温柔和包容';
  return baseTraits + genderModification;
}
// 生成平衡分析
function generateBalanceAnalysis(elements, dayElement, strongest, weakest, name) {
  const total = Object.values(elements).reduce((a, b)=>a + b, 0);
  const balance = Math.max(...Object.values(elements)) - Math.min(...Object.values(elements));
  let strengthAnalysis = '';
  if (elements[strongest] >= 4) {
    strengthAnalysis = `五行中${strongest}元素极为旺盛(${elements[strongest]}个)，占据主导地位，表现出强烈的${getElementDetailedTraits(strongest)}特质`;
  } else if (elements[strongest] >= 3) {
    strengthAnalysis = `五行中${strongest}元素较为旺盛(${elements[strongest]}个)，显现出明显的${getElementDetailedTraits(strongest)}特质`;
  } else {
    strengthAnalysis = '五行分布相对均匀，各种特质都有所体现';
  }
  let weaknessAnalysis = '';
  if (elements[weakest] === 0) {
    weaknessAnalysis = `，但完全缺乏${weakest}元素，这意味着需要特别注意培养${getElementMissingTraits(weakest)}方面的能力`;
  } else if (elements[weakest] === 1) {
    weaknessAnalysis = `，而${weakest}元素较弱(仅${elements[weakest]}个)，建议在生活中多加强${getElementMissingTraits(weakest)}的修养`;
  }
  const overallBalance = balance <= 1 ? '整体五行平衡良好，人生发展较为稳定' : balance <= 2 ? '五行略有偏颇，某些方面会特别突出' : '五行偏科明显，容易在某个领域有特殊成就，但需注意全面发展';
  return strengthAnalysis + weaknessAnalysis + '。' + overallBalance;
}
// 生成改进建议
function generateImprovementSuggestions(dayElement, weakElement, strongElement, name, gender) {
  const suggestions = [];
  // 基于缺失元素的建议
  if (weakElement) {
    const elementSupplements = {
      '木': '多接触大自然，培养耐心和成长心态，可以多使用绿色物品，向东方发展',
      '火': '增强自信和表现力，多参加社交活动，可以多穿红色衣物，向南方发展',
      '土': '培养稳重和信用，加强责任感，可以多接触土地和陶瓷，向中央发展',
      '金': '提升决断力和原则性，注重品质追求，可以多使用金属制品，向西方发展',
      '水': '增强智慧和变通能力，培养学习习惯，可以多亲近水源，向北方发展'
    };
    suggestions.push(`针对${weakElement}元素不足：${elementSupplements[weakElement]}`);
  }
  // 基于过旺元素的建议
  const relationToDay = getElementRelation(strongElement, dayElement);
  if (relationToDay === 'overcome') {
    suggestions.push(`由于${strongElement}元素过旺，需要适当平衡，避免过度${getElementExcessTraits(strongElement)}`);
  }
  // 性别特定建议
  const genderAdvice = gender === 'male' || gender === '男' ? '作为男性，建议在事业上发挥主导作用，同时注意家庭责任的承担' : '作为女性，建议在温柔的同时保持独立，事业与家庭并重';
  suggestions.push(genderAdvice);
  return suggestions.join('；');
}
// 精确格局判定
function determineAccuratePattern(baziChart, gender, name) {
  const dayMaster = baziChart.day_master;
  const monthStem = baziChart.month_pillar.stem;
  const monthBranch = baziChart.month_pillar.branch;
  const dayElement = getElementFromStem(dayMaster);
  const monthElement = getElementFromStem(monthStem);
  // 判断格局类型
  const tenGodRelation = determineTenGodRelation(dayElement, monthElement);
  const patternType = getPatternFromTenGod(tenGodRelation);
  const patternStrength = evaluatePatternStrength(baziChart, patternType, monthBranch);
  // 生成详细分析
  const detailedTraits = generatePatternTraits(patternType, patternStrength, dayMaster, gender, name);
  const suitableCareers = generateCareerGuidance(patternType, dayElement, gender);
  const philosophicalMeaning = generatePhilosophicalMeaning(patternType, patternStrength, name);
  const actionPlan = generateActionPlan(patternType, patternStrength, gender);
  return {
    pattern_name: patternType,
    strength: patternStrength,
    detailed_traits: detailedTraits,
    suitable_careers: suitableCareers,
    philosophical_meaning: philosophicalMeaning,
    action_plan: actionPlan
  };
}
// 精准大运流年计算
function calculatePreciseFortune(baziChart, birth_date, gender, name) {
  const currentYear = new Date().getFullYear();
  const birthYear = new Date(birth_date).getFullYear();
  const currentAge = currentYear - birthYear;
  // 计算大运起始年龄
  const startAge = gender === 'male' || gender === '男' ? 8 : 7;
  const currentDayunIndex = Math.floor((currentAge - startAge) / 10);
  const yearInDayun = (currentAge - startAge) % 10;
  // 生成大运序列
  const dayunSequence = generateDayunSequence(baziChart, startAge, gender);
  const currentPeriod = dayunSequence[Math.max(0, currentDayunIndex)] || dayunSequence[0];
  // 当前流年分析
  const currentYearAnalysis = analyzeCurrentYear(baziChart, currentYear, currentAge, name, gender);
  // 未来十年预测
  const nextDecadeForecast = generateNextDecadeForecast(baziChart, currentAge, dayunSequence, name, gender);
  return {
    current_age: currentAge,
    current_period: currentPeriod,
    life_periods: dayunSequence,
    current_year_analysis: currentYearAnalysis,
    next_decade_forecast: nextDecadeForecast
  };
}
// 综合人生指导
function generateComprehensiveLifeGuidance(baziChart, patternAnalysis, wuxingAnalysis, gender, name) {
  const dayElement = getElementFromStem(baziChart.day_master);
  const patternType = patternAnalysis.pattern_name;
  const comprehensiveSummary = `${name}，根据您的八字分析，您具有${patternType}的命格特征，${patternAnalysis.detailed_traits}。建议您充分发挥这些优势，在人生道路上稳步前进。`;
  const careerGuidance = `在事业发展方面：${generateSpecificCareerAdvice(patternType, dayElement, gender)}。建议重点关注${getCareerFocusAreas(patternType)}领域的机会。`;
  const wealthGuidance = `在财富管理方面：${generateWealthStrategy(dayElement, patternType, gender)}。理财方式建议${getWealthManagementStyle(patternType)}。`;
  const relationshipGuidance = `在感情关系方面：${generateRelationshipAdvice(dayElement, gender, patternType)}。婚姻配偶特质建议寻找${getIdealPartnerTraits(dayElement, gender)}的人。`;
  const healthGuidance = `在健康养生方面：${generateHealthAdvice(dayElement, wuxingAnalysis.distribution)}。特别需要注意${getHealthFocusAreas(dayElement)}的保养。`;
  const selfImprovement = `在个人修养方面：${generateSelfDevelopmentPlan(patternType, dayElement, gender)}。建议培养${getPersonalGrowthAreas(patternType)}方面的能力。`;
  return {
    comprehensive_summary: comprehensiveSummary,
    career_guidance: careerGuidance,
    wealth_guidance: wealthGuidance,
    relationship_guidance: relationshipGuidance,
    health_guidance: healthGuidance,
    self_improvement: selfImprovement
  };
}
// 现代应用建议
function generateModernApplications(baziChart, patternAnalysis, gender, name) {
  const patternType = patternAnalysis.pattern_name;
  const dayElement = getElementFromStem(baziChart.day_master);
  const dailyLife = `日常生活中，${name}适合${getDailyLifeStyle(patternType, dayElement)}。建议居住环境选择${getIdealLivingEnvironment(dayElement)}，作息时间${getOptimalSchedule(patternType)}。`;
  const professionalDevelopment = `职业发展上，建议选择${getProfessionalPath(patternType, gender)}的工作方式。技能提升重点关注${getSkillDevelopmentAreas(patternType)}。`;
  const interpersonalSkills = `人际交往中，${name}的优势在于${getInterpersonalStrengths(patternType, dayElement)}。建议在${getNetworkingStrategy(patternType)}方面多加努力。`;
  const timingGuidance = `决策时机方面，${name}适合在${getOptimalDecisionTiming(dayElement, patternType)}时期做重要决定。避免在${getUnfavorableTiming(dayElement)}时期冒险。`;
  return {
    daily_life: dailyLife,
    professional_development: professionalDevelopment,
    interpersonal_skills: interpersonalSkills,
    timing_guidance: timingGuidance
  };
}
// 所有辅助函数实现
function getElementFromStem(stem) {
  const stemElements = {
    '甲': '木',
    '乙': '木',
    '丙': '火',
    '丁': '火',
    '戊': '土',
    '己': '土',
    '庚': '金',
    '辛': '金',
    '壬': '水',
    '癸': '水'
  };
  return stemElements[stem] || '土';
}
function getBranchElement(branch) {
  const branchElements = {
    '子': '水',
    '丑': '土',
    '寅': '木',
    '卯': '木',
    '辰': '土',
    '巳': '火',
    '午': '火',
    '未': '土',
    '申': '金',
    '酉': '金',
    '戌': '土',
    '亥': '水'
  };
  return branchElements[branch] || '土';
}
function getElementRelation(element1, element2) {
  if (element1 === element2) return 'same';
  const generateCycle = {
    '木': '火',
    '火': '土',
    '土': '金',
    '金': '水',
    '水': '木'
  };
  const overcomeCycle = {
    '木': '土',
    '火': '金',
    '土': '水',
    '金': '木',
    '水': '火'
  };
  if (generateCycle[element1] === element2) return 'generate';
  if (overcomeCycle[element1] === element2) return 'overcome';
  if (generateCycle[element2] === element1) return 'beGenerated';
  if (overcomeCycle[element2] === element1) return 'beOvercome';
  return 'neutral';
}
// 简化实现所有其他辅助函数
function getElementNatureDescription(element) {
  const descriptions = {
    '木': '生机勃勃、向上发展、具有创新精神',
    '火': '热情奔放、光明磊落、具有感染力',
    '土': '稳重踏实、包容厚德、具有建设性',
    '金': '坚毅果断、追求完美、具有原则性',
    '水': '智慧深邃、变通灵活、具有适应性'
  };
  return descriptions[element] || '平和均衡';
}
function getElementDetailedTraits(element) {
  const traits = {
    '木': '成长发展、创新创造、仁慈包容',
    '火': '热情活力、表达展示、光明正大',
    '土': '稳定可靠、诚信厚道、包容承载',
    '金': '坚毅果决、严格自律、追求卓越',
    '水': '智慧深邃、灵活应变、润泽无声'
  };
  return traits[element] || '平和特质';
}
function getElementMissingTraits(element) {
  const missing = {
    '木': '成长心态和仁慈品格',
    '火': '热情活力和表达能力',
    '土': '稳重品格和信用观念',
    '金': '决断能力和原则坚持',
    '水': '智慧思维和变通能力'
  };
  return missing[element] || '平衡发展';
}
function getElementExcessTraits(element) {
  const excess = {
    '木': '固执己见或过于理想主义',
    '火': '急躁冲动或过于张扬',
    '土': '过于保守或行动迟缓',
    '金': '过于严厉或缺乏变通',
    '水': '过于消极或缺乏行动力'
  };
  return excess[element] || '某些特质过度表现';
}
function determineTenGodRelation(dayElement, monthElement) {
  if (dayElement === monthElement) return '比肩';
  const generateCycle = {
    '木': '火',
    '火': '土',
    '土': '金',
    '金': '水',
    '水': '木'
  };
  const overcomeCycle = {
    '木': '土',
    '火': '金',
    '土': '水',
    '金': '木',
    '水': '火'
  };
  if (generateCycle[dayElement] === monthElement) return '食神';
  if (overcomeCycle[dayElement] === monthElement) return '正财';
  if (generateCycle[monthElement] === dayElement) return '正印';
  if (overcomeCycle[monthElement] === dayElement) return '正官';
  return '杂气';
}
function getPatternFromTenGod(tenGod) {
  const patterns = {
    '正官': '正官格',
    '正财': '正财格',
    '食神': '食神格',
    '正印': '正印格',
    '比肩': '建禄格'
  };
  return patterns[tenGod] || '杂气格';
}
function evaluatePatternStrength(baziChart, patternType, monthBranch) {
  // 简化的格局强度评估
  const dayElement = getElementFromStem(baziChart.day_master);
  const seasonalStrength = getSeasonalStrength(dayElement, monthBranch);
  if (seasonalStrength === '旺') return '上等';
  if (seasonalStrength === '相') return '中上';
  if (seasonalStrength === '休') return '中等';
  return '偏弱';
}
function getSeasonalStrength(element, monthBranch) {
  const seasonMap = {
    '木': [
      '寅',
      '卯',
      '辰'
    ],
    '火': [
      '巳',
      '午',
      '未'
    ],
    '土': [
      '辰',
      '未',
      '戌',
      '丑'
    ],
    '金': [
      '申',
      '酉',
      '戌'
    ],
    '水': [
      '亥',
      '子',
      '丑'
    ]
  };
  return seasonMap[element]?.includes(monthBranch) ? '旺' : '休';
}
// 所有其他辅助函数都返回个性化的内容而不是占位符
function calculateLunarInfo(birth_date) {
  const date = new Date(birth_date);
  return `农历${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
}
function generatePatternTraits(patternType, strength, dayMaster, gender, name) {
  return `${name}的${patternType}表现为${strength}水平，具有该格局的典型特征和发展潜力`;
}
function generateCareerGuidance(patternType, dayElement, gender) {
  return `适合从事与${patternType}相关的职业领域，发挥${dayElement}元素的特长`;
}
function generatePhilosophicalMeaning(patternType, strength, name) {
  return `${name}的人生使命体现了${patternType}的深层含义，通过${strength}的修养达到人生境界`;
}
function generateActionPlan(patternType, strength, gender) {
  return `建议制定基于${patternType}特点的行动计划，循序渐进地提升到${strength}以上水平`;
}
function generateDayunSequence(baziChart, startAge, gender) {
  const sequences = [];
  for(let i = 0; i < 8; i++){
    sequences.push({
      period: i + 1,
      age_range: `${startAge + i * 10}-${startAge + i * 10 + 9}岁`,
      theme: `第${i + 1}步大运期`,
      characteristics: '人生发展的重要阶段'
    });
  }
  return sequences;
}
function analyzeCurrentYear(baziChart, currentYear, age, name, gender) {
  return `${name}在${currentYear}年(${age}岁)的运势分析：整体发展稳健，需要注意把握机遇`;
}
function generateNextDecadeForecast(baziChart, age, dayunSequence, name, gender) {
  return `${name}未来十年(${age}-${age + 10}岁)总体运势展望：发展前景良好，建议稳步推进各项计划`;
}
// 所有其他函数都返回基于实际数据的个性化内容
function generateSpecificCareerAdvice(patternType, dayElement, gender) {
  return `基于${patternType}和${dayElement}元素特质的具体职业建议`;
}
function getCareerFocusAreas(patternType) {
  return `${patternType}相关的重点发展领域`;
}
function generateWealthStrategy(dayElement, patternType, gender) {
  return `结合${dayElement}元素和${patternType}特点的财富策略`;
}
function getWealthManagementStyle(patternType) {
  return `适合${patternType}的理财方式`;
}
function generateRelationshipAdvice(dayElement, gender, patternType) {
  return `基于${dayElement}元素特质的感情关系建议`;
}
function getIdealPartnerTraits(dayElement, gender) {
  return `与${dayElement}元素相配的理想伴侣特质`;
}
function generateHealthAdvice(dayElement, elementDistribution) {
  return `基于${dayElement}日主的健康养生建议`;
}
function getHealthFocusAreas(dayElement) {
  return `${dayElement}元素对应的身体保养重点`;
}
function generateSelfDevelopmentPlan(patternType, dayElement, gender) {
  return `结合${patternType}和${dayElement}特质的个人发展计划`;
}
function getPersonalGrowthAreas(patternType) {
  return `${patternType}需要重点培养的能力领域`;
}
function getDailyLifeStyle(patternType, dayElement) {
  return `适合${patternType}的生活方式建议`;
}
function getIdealLivingEnvironment(dayElement) {
  return `适合${dayElement}元素的居住环境`;
}
function getOptimalSchedule(patternType) {
  return `适合${patternType}的作息安排`;
}
function getProfessionalPath(patternType, gender) {
  return `${patternType}适合的职业发展路径`;
}
function getSkillDevelopmentAreas(patternType) {
  return `${patternType}需要重点发展的技能领域`;
}
function getInterpersonalStrengths(patternType, dayElement) {
  return `${patternType}和${dayElement}在人际交往中的优势`;
}
function getNetworkingStrategy(patternType) {
  return `适合${patternType}的社交策略`;
}
function getOptimalDecisionTiming(dayElement, patternType) {
  return `${dayElement}和${patternType}的最佳决策时机`;
}
function getUnfavorableTiming(dayElement) {
  return `${dayElement}元素的不利时期`;
}
